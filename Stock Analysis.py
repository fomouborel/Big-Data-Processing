# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K_iZ6cluerLizOd3EjhCRRX9_VlvtQZC
"""

!pip install streamlit

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import matplotlib.pyplot as plt
# import seaborn as sns
# from pyspark.sql import SparkSession
# from pyspark.sql.window import Window
# from pyspark.sql.functions import col, lag, datediff, count, year, month, weekofyear, avg
# import pandas as pd
# import yfinance as yf
# from pyspark.sql.functions import desc
# from pyspark.sql import functions as F
# 
# # Cr√©er une session Spark
# spark = SparkSession.builder.appName("Stock Analysis App").getOrCreate()
# 
# # Charger la liste des symboles NASDAQ
# def load_nasdaq_symbols():
#     url = "https://www.nasdaqtrader.com/dynamic/SymDir/nasdaqlisted.txt"
#     df = pd.read_csv(url, sep='|')
#     return df['Symbol'].tolist()
# 
# nasdaq_symbols = load_nasdaq_symbols()
# 
# def get_stock_data(ticker, period):
#     ticker_data = yf.Ticker(ticker)
#     df = ticker_data.history(period=period).reset_index()
#     return spark.createDataFrame(df)
# 
# def deduce_period(df, date_col="Date"):
#     window = Window.orderBy(date_col)
#     df = df.withColumn("Prev_Date", lag(date_col).over(window))
#     df = df.withColumn("Date_Diff", datediff(col(date_col), col("Prev_Date")))
#     period_df = df.groupBy("Date_Diff").agg(count("*").alias("count"))
#     most_common_period = period_df.orderBy(col("count").desc()).first()
#     return most_common_period["Date_Diff"] if most_common_period else None
# 
# from pyspark.sql.functions import col
# 
# def calculate_daily_return(df):
#     df = df.withColumn("Daily_Return", (col("Close") - col("Open")) / col("Open"))
#     return df
# 
# def plot_daily_return(df):
#     df = df.withColumn("Year", year("Date"))
#     df = df.withColumn("Month", month("Date"))
#     df = df.withColumn("Week", weekofyear("Date"))
#     df = df.toPandas()
#     plt.figure(figsize=(10, 5))
#     sns.lineplot(data=df, x="Week", y="Daily_Return", hue="Year", marker="o")
#     plt.title("Weekly Average of Closing Prices")
#     plt.xlabel("Week")
#     plt.ylabel("Average Closing Price")
#     plt.legend(title="Year")
#     st.pyplot(plt)
# 
# def calculate_average_prices(df):
#     df = df.withColumn("Year", year("Date"))
#     df = df.withColumn("Month", month("Date"))
#     df = df.withColumn("Week", weekofyear("Date"))
#     weekly_avg = df.groupBy("Year", "Week").agg(avg("Open").alias("Avg_Open"), avg("Close").alias("Avg_Close"))
#     monthly_avg = df.groupBy("Year", "Month").agg(avg("Open").alias("Avg_Open"), avg("Close").alias("Avg_Close"))
#     yearly_avg = df.groupBy("Year").agg(avg("Open").alias("Avg_Open"), avg("Close").alias("Avg_Close"))
#     return weekly_avg, monthly_avg, yearly_avg
# 
# def get_highest_daily_returns(df, top_n=1):
#     df = df.withColumn("Year", year("Date"))
#     df = df.withColumn("Month", month("Date"))
#     df = df.withColumn("Week", weekofyear("Date"))
#     return df.orderBy(desc("Daily_Return")).limit(top_n)
# 
# def plot_average_prices(weekly_avg, monthly_avg, yearly_avg):
#     weekly_pdf = weekly_avg.toPandas()
#     plt.figure(figsize=(10, 5))
#     sns.lineplot(data=weekly_pdf, x="Week", y="Avg_Close", hue="Year", marker="o")
#     plt.title("Average Weekly Closing Price")
#     plt.xlabel("Week")
#     plt.ylabel("Average Closing Price")
#     plt.legend(title="Year")
#     st.pyplot(plt)
# 
# def calculate_average_daily_returns(df):
#     # Ajouter des colonnes pour l'ann√©e, le mois et la semaine
#     df = df.withColumn("Year", year("Date"))
#     df = df.withColumn("Month", month("Date"))
#     df = df.withColumn("Week", weekofyear("Date"))
# 
#     # Calculer le rendement quotidien moyen par p√©riode
#     weekly_avg_return = df.groupBy("Year", "Week").agg(avg("Daily_Return").alias("Avg_Daily_Return"))
#     monthly_avg_return = df.groupBy("Year", "Month").agg(avg("Daily_Return").alias("Avg_Daily_Return"))
#     yearly_avg_return = df.groupBy("Year").agg(avg("Daily_Return").alias("Avg_Daily_Return"))
# 
#     return weekly_avg_return, monthly_avg_return, yearly_avg_return
# 
# def plot_average_daily_returns(weekly_avg_return, monthly_avg_return, yearly_avg_return):
#     # Convertir en pandas pour faciliter la visualisation
#     weekly_pdf = weekly_avg_return.toPandas()
#     monthly_pdf = monthly_avg_return.toPandas()
#     yearly_pdf = yearly_avg_return.toPandas()
# 
#     # Tracer les rendements moyens par semaine
#     plt.figure(figsize=(12, 6))
#     sns.lineplot(data=weekly_pdf, x='Week', y='Avg_Daily_Return', marker='o', color='blue')
#     plt.title('Average Daily Return by Week')
#     plt.xlabel('Week')
#     plt.ylabel('Average Daily Return')
#     plt.grid(True)
#     st.pyplot(plt)
# 
#     # Tracer les rendements moyens par mois
#     plt.figure(figsize=(12, 6))
#     sns.lineplot(data=monthly_pdf, x='Month', y='Avg_Daily_Return', marker='o', color='green')
#     plt.title('Average Daily Return by Month')
#     plt.xlabel('Month')
#     plt.ylabel('Average Daily Return')
#     plt.grid(True)
#     st.pyplot(plt)
# 
#     # Tracer les rendements moyens par ann√©e
#     plt.figure(figsize=(12, 6))
#     sns.lineplot(data=yearly_pdf, x='Year', y='Avg_Daily_Return', marker='o', color='red')
#     plt.title('Average Daily Return by Year')
#     plt.xlabel('Year')
#     plt.ylabel('Average Daily Return')
#     plt.grid(True)
#     st.pyplot(plt)
# 
# def daily_changes(df):
#     # Fen√™tre pour calculer la variation quotidienne
#     window = Window.orderBy("Date")
#     df = df.withColumn("Prev_Close", lag("Close").over(window))
#     df = df.withColumn("Daily_Change", (col("Close") - col("Prev_Close")) / col("Prev_Close"))
#     return df
# 
# def plot_daily_changes(df):
#     # Convertir en pandas pour faciliter la visualisation
#     pdf = df.toPandas()
# 
#     # Tracer la variation quotidienne
#     plt.figure(figsize=(12, 6))
#     sns.lineplot(data=pdf, x='Date', y='Daily_Change', color='blue')
# 
#     # Ajouter des titres et des labels
#     plt.title('Daily Price Change')
#     plt.xlabel('Date')
#     plt.ylabel('Price Change (%)')
#     plt.grid(True)
#     st.pyplot(plt)
# 
# def moving_average(df, col_name, window_size):
#     # D√©finir la fen√™tre pour le calcul de la moyenne mobile
#     window_spec = Window.orderBy("Date").rowsBetween(-(window_size - 1), 0)
# 
#     # Calculer la moyenne mobile
#     df = df.withColumn(f"Moving_Avg_{col_name}", F.avg(F.col(col_name)).over(window_spec))
# 
#     return df
# 
# # Fonction pour afficher le graphique
# def plot_moving_average(df, col_name, window_size):
#     df = df.toPandas()
# 
#     # Tracer les prix d'origine et la moyenne mobile
#     plt.figure(figsize=(12, 6))
# 
#     # Tracer les valeurs d'origine
#     sns.lineplot(data=df, x='Date', y=col_name, label=f'{col_name} Price', color='blue')
# 
#     # Tracer la moyenne mobile
#     sns.lineplot(data=df, x='Date', y=f'Moving_Avg_{col_name}', label=f'{window_size}-Day Moving Average', color='red')
# 
#     # Ajouter des titres et des labels
#     plt.title(f'{col_name} Price with {window_size}-Day Moving Average')
#     plt.xlabel('Date')
#     plt.ylabel(f'{col_name} Price')
#     plt.xticks(rotation=45)
#     plt.legend(title="Legend")
#     plt.grid(True)
#     st.pyplot(plt)
# 
# # Interface Streamlit
# st.title("üìà Stock Data Analysis")
# 
# # S√©lection de l'utilisateur
# ticker = st.selectbox("Select a Stock:", nasdaq_symbols)
# period = st.selectbox("Select Analysis Period:", ["1mo", "3mo", "6mo", "1y", "2y", "5y", "10y"])
# 
# # Charger les donn√©es
# data = get_stock_data(ticker, period)
# 
# if st.button("Analyze"):
#     period_detected = deduce_period(data)
# 
#     st.write(f"Most Frequent Data Period: {period_detected} days")
# 
#     weekly_avg, monthly_avg, yearly_avg = calculate_average_prices(data)
# 
#     spark_df_with_returns = calculate_daily_return(data)
#     highest_return = get_highest_daily_returns(spark_df_with_returns).toPandas()
# 
#     # Average Prices
#     st.write("### üìÖ Trend in Average Weekly Closing Price")
#     plot_average_prices(weekly_avg, monthly_avg, yearly_avg)
# 
#     plot_daily_return(spark_df_with_returns)
#     st.write(f"Period with highest daily return: {highest_return.iloc[0]['Date']} with {highest_return.iloc[0]['Daily_Return']}")
# 
#     st.subheader("üìä Average Daily Return")
#     weekly_avg_return, monthly_avg_return, yearly_avg_return = calculate_average_daily_returns(spark_df_with_returns)
# 
#     # Plot charts
#     plot_average_daily_returns(weekly_avg_return, monthly_avg_return, yearly_avg_return)
# 
#     st.subheader("üìä Daily Changes")
#     df_with_changes = daily_changes(data)
#     plot_daily_changes(df_with_changes)
# 
#     st.subheader("üìä Moving Average")
#     # Column selection and window size via Streamlit
#     col_options = ["Open", "Close"]
#     col_name = st.selectbox("Select Column for Moving Average", col_options)
# 
#     window_size = st.slider("Select Window Size", min_value=1, max_value=30, value=5)
# 
#     # Calculate Moving Average
#     result_df = moving_average(data, col_name, window_size)
# 
#     # Display the graph
#     plot_moving_average(result_df, col_name, window_size)
#

!pip install pyngrok

!streamlit run app.py &>/dev/null &

!ngrok authtoken 2u5iyLI5cQWwVBH1u1LnuCzyPCj_GiQ5yTWk1q16WWHiCG6C

from pyngrok import ngrok

# Ouvrir un tunnel sur le port 8501 (port par d√©faut de Streamlit)
url = ngrok.connect(8501, "http").public_url
print(f"Streamlit est accessible √† cette adresse : {url}")